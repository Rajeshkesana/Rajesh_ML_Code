# -*- coding: utf-8 -*-
"""Untitled57.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ymJ2wKgsjTFOcaiRApHi0HxoJsphQA7R
"""

import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

sns.set(style="whitegrid")

class HopfieldNetwork:
    def __init__(self):
        self.W = None
        self.n = None

    def train(self, patterns):
        """
        Train Hopfield network using Hebbian learning.
        Patterns must be in {-1, +1}.
        """
        patterns = np.array(patterns)
        self.n = patterns.shape[1]
        self.W = np.zeros((self.n, self.n))

        for p in patterns:
            self.W += np.outer(p, p)

        # no self-connections
        np.fill_diagonal(self.W, 0)
        self.W /= len(patterns)

    def energy(self, state):
        """
        Compute Hopfield energy: E(x) = -1/2 x^T W x
        """
        return -0.5 * state @ self.W @ state.T

    def update(self, state):
        """
        Asynchronous update: update one random neuron at a time.
        """
        i = np.random.randint(0, self.n)
        state[i] = 1 if self.W[i] @ state >= 0 else -1
        return state

    def recall(self, initial_state, steps=50):
        """
        Recall a memory starting from an initial (possibly noisy) pattern.
        Returns the trajectory of states and energies.
        """
        state = initial_state.copy()
        states = [state.copy()]
        energies = [self.energy(state)]

        for _ in range(steps):
            state = self.update(state.copy())
            states.append(state.copy())
            energies.append(self.energy(state))

        return np.array(states), np.array(energies)

def to_pm1(x):
    return np.where(x > 0, 1, -1)

def plot_pattern(vec, size=(8, 8), title="Pattern"):
    plt.imshow(vec.reshape(size), cmap="binary")
    plt.title(title)
    plt.axis("off")
    plt.show()

# Simple 8x8 patterns (you can replace them with letters or shapes)
A = np.array([
 [0,0,1,1,1,1,0,0],
 [0,1,0,0,0,0,1,0],
 [1,0,0,0,0,0,0,1],
 [1,1,1,1,1,1,1,1],
 [1,0,0,0,0,0,0,1],
 [1,0,0,0,0,0,0,1],
 [1,0,0,0,0,0,0,1],
 [1,0,0,0,0,0,0,1]
])

B = np.rot90(A)
C = np.flip(A, axis=1)

patterns = np.array([to_pm1(A.flatten()),
                     to_pm1(B.flatten()),
                     to_pm1(C.flatten())])

hop = HopfieldNetwork()
hop.train(patterns)

# Add noise by flipping bits
def flip_bits(x, p=0.2):
    mask = np.random.rand(len(x)) < p
    noisy = x.copy()
    noisy[mask] *= -1
    return noisy

test_pattern = patterns[0]
noisy = flip_bits(test_pattern, p=0.3)

plot_pattern(test_pattern, title="Original Pattern")
plot_pattern(noisy, title="Noisy Input")

states, energies = hop.recall(noisy, steps=80)

# final recovered pattern
plot_pattern(states[-1], title="Reconstructed Pattern")

# energy plot
plt.figure(figsize=(6,4))
plt.plot(energies)
plt.title("Energy Descent During Recall")
plt.xlabel("Step")
plt.ylabel("Energy")
plt.show()

def random_pm1_patterns(num, n):
    return to_pm1(np.random.randint(0,2,(num,n)))

def evaluate_capacity(N=100, max_patterns=50, trials=5):
    success_rates = []

    for P in range(1, max_patterns+1):
        successes = 0

        for _ in range(trials):
            pats = random_pm1_patterns(P, N)
            net = HopfieldNetwork()
            net.train(pats)

            for p in pats:
                noisy = flip_bits(p, p=0.1)
                recovered, _ = net.recall(noisy, steps=50)
                if np.array_equal(recovered[-1], p):
                    successes += 1

        success_rates.append(successes / (P * trials))

    return success_rates


rates = evaluate_capacity(N=100, max_patterns=40)

plt.figure(figsize=(7,4))
plt.plot(range(1,41), rates, marker='o')
plt.axvline(x=int(0.138*100), color='red', linestyle='--', label="Theoretical Capacity")
plt.title("Hopfield Network Capacity Curve")
plt.xlabel("Number of Stored Patterns")
plt.ylabel("Successful Recall Rate")
plt.legend()
plt.show()

def find_spurious_attractors(net, patterns, trials=100):
    attractors = []

    for _ in range(trials):
        s = random_pm1_patterns(1, net.n)[0]
        recalled, _ = net.recall(s, steps=50)
        final = tuple(recalled[-1])

        if final not in attractors:
            attractors.append(final)

    # remove true memories
    true = {tuple(p) for p in patterns}
    spurious = [np.array(a) for a in attractors if tuple(a) not in true]
    return spurious

spurious = find_spurious_attractors(hop, patterns)

print(f"Found {len(spurious)} spurious attractors.")

# 2-neuron toy network
W2 = np.array([[0, 1],
               [1, 0]])

def energy_2d(x1, x2):
    x = np.array([x1, x2])
    return -0.5 * x @ W2 @ x.T

grid = np.linspace(-1, 1, 200)
E = np.zeros((200,200))

for i, x1 in enumerate(grid):
    for j, x2 in enumerate(grid):
        E[i,j] = energy_2d(x1, x2)

plt.figure(figsize=(6,5))
plt.contourf(grid, grid, E, levels=50, cmap='viridis')
plt.colorbar(label="Energy")
plt.title("Energy Landscape of a 2-Neuron Hopfield System")
plt.xlabel("x1")
plt.ylabel("x2")
plt.show()

